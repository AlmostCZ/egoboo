//********************************************************************************************
//*
//*    This file is part of Egoboo.
//*
//*    Egoboo is free software: you can redistribute it and/or modify it
//*    under the terms of the GNU General Public License as published by
//*    the Free Software Foundation, either version 3 of the License, or
//*    (at your option) any later version.
//*
//*    Egoboo is distributed in the hope that it will be useful, but
//*    WITHOUT ANY WARRANTY; without even the implied warranty of
//*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//*    General Public License for more details.
//*
//*    You should have received a copy of the GNU General Public License
//*    along with Egoboo.  If not, see <http://www.gnu.org/licenses/>.
//*
//********************************************************************************************

/// @file   egolib/Math/_Tuple.hpp
/// @brief  Tuples.
/// @author Michael Heilmann

#pragma once



#include "egolib/Math/Dimensionality.hpp"
#include "egolib/Math/TemplateUtilities.hpp"



namespace Ego {
namespace Math {

/**
 * @brief A tuple is the base class of vectors and points.
 * @tparam _ElementType the element type. Must fulfil the ordered integral domain concept.
 * @tparam _Dimensionality the dimensionality. Must fulfil the dimensionality concept.
 */
template <typename _ElementType, size_t _Dimensionality>
struct Tuple {
public:
    /** @brief The type of the elements of this tuple type. */
    typedef _ElementType ElementType;

    /**
     * @brief The dimensionality of this tuple.
     * @return the dimensionality of this tuple
     */
    constexpr static size_t dimensionality() {
        return _Dimensionality;
    }

    /** @invariant The dimensionality be a positive integral constant. */
    static_assert(IsDimensionality<_Dimensionality>::value, "_Dimensionality must fulfil the dimensionality concept");


	/** @brief @a MyType is the type of this template/template specialization. */
	typedef Tuple<ElementType, _Dimensionality> MyType;


private:
	/**
	 * @brief
	 *  The elements of this tuple.
	 */
	std::array<ElementType, _Dimensionality> _elements;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Generator construction.
protected:

    /**
     * @brief Construct this tuple with the values generated by a sequence generator.
     * @tparam _GeneratorType the generator type
     * @tparam ... Index indices 0, 1, ..., dimensionality() - 1
     */
    template <typename _GeneratorType, size_t ... Index>
    Tuple(const _GeneratorType& generator, std::index_sequence<Index ...>)
        : Tuple(generator(Index) ...) {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Direct construction.
protected:

	/**
	 * @brief Construct this tuple with the specified element values.
	 * @param first, ... rest the specified element values
     * @pre The number of specified element values must be equal to the dimensionality of the tuple type.
     * @pre Each specified element value must be convertible into the element type of the tuple type.
	 */
	template<
        typename ... ArgumentTypes,
        typename = 
            std::enable_if_t<
                ((sizeof...(ArgumentTypes)) + 1) == MyType::dimensionality() &&
                Core::AllTrue<std::is_convertible<ArgumentTypes, ElementType>::value ...>::value
            >
    >
	Tuple(ElementType&& first, ArgumentTypes&& ... rest)
		: _elements{ first, static_cast<ElementType>(rest) ... } {
		static_assert(dimensionality() == 1 + sizeof ... (rest), "wrong number of arguments");
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Default construction.
protected:
	/**
	 * @brief
	 *	Default-construct this tuple.
	 */
	Tuple() : _elements() {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Copy construction.
protected:
	/**
	 * @brief
	 *  Copy-construct this tuple with the values of another tuple.
	 * @param other
	 *  the other tuple
	 */
	Tuple(const MyType& other) : _elements(other._elements) {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Assignment.
protected:
	/**
	 * @brief
	 *  Assign this tuple with the values of another tuple.
	 * @param other
	 *  the other tuple
	 */
	void assign(const MyType& other) {
        for (auto i = 0; i < dimensionality(); ++i) {
            _elements[i] = other._elements[i];
        }
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Element access.
public:
	/**
	 * @{
	 * @brief Get the tuple element at the specified index.
	 * @param index the index
	 * @return the tuple element at the specified index
	 * @pre The index is within bounds.
	 */
	ElementType& at(size_t const& index) {
	#ifdef _DEBUG
		ID_ASSERT(index < dimensionality());
	#endif
		return _elements[index];
	}

	const ElementType& at(size_t const& index) const {
	#ifdef _DEBUG
		ID_ASSERT(index < dimensionality());
	#endif
		return _elements[index];
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Minimal/Maximal elements.

private:
    /** @internal */
    template <size_t ... Index>
    ElementType minhelper(std::index_sequence<Index ...>) const {
        return std::min({(this->_elements[Index]) ...});
    }

    /** @internal */
    template <size_t ... Index>
    ElementType maxhelper(std::index_sequence<Index ...>) const {
        return std::max({(this->_elements[Index]) ...});
    }


public:
    /**
     * @brief Get the minimum element value of this tuple.
     * @return the minimum element value of this tuple
     */
    ElementType min() const {
        return minhelper(std::index_sequence<MyType::dimensionality()>{});
    }

    /**
     * @brief Get the maximal element value of this tuple.
     * @return the maximal element value of this tuple
     */
    ElementType max() const {
        return maxhelper(std::index_sequence<MyType::dimensionality()>{});
    }

};

} // namespace Math
} // namespace Ego
