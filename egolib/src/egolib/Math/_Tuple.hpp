//********************************************************************************************
//*
//*    This file is part of Egoboo.
//*
//*    Egoboo is free software: you can redistribute it and/or modify it
//*    under the terms of the GNU General Public License as published by
//*    the Free Software Foundation, either version 3 of the License, or
//*    (at your option) any later version.
//*
//*    Egoboo is distributed in the hope that it will be useful, but
//*    WITHOUT ANY WARRANTY; without even the implied warranty of
//*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//*    General Public License for more details.
//*
//*    You should have received a copy of the GNU General Public License
//*    along with Egoboo.  If not, see <http://www.gnu.org/licenses/>.
//*
//********************************************************************************************

/// @file   egolib/Math/_Tuple.hpp
/// @brief  Tuples.
/// @author Michael Heilmann

#pragma once



#include "egolib/Math/Dimensionality.hpp"
#include "egolib/Math/TemplateUtilities.hpp"



namespace Ego {
namespace Math {

/**
 * @brief A tuple is the base class of vectors and points.
 * @tparam _ElementType the element type. Must fulfil the ordered integral domain concept.
 * @tparam _Dimensionality the dimensionality. Must fulfil the dimensionality concept.
 */
template <typename _ElementType, size_t _Dimensionality>
struct Tuple {
public:
    /** @brief The type of the elements of this tuple type. */
    using ElementType = _ElementType;

    /**
     * @brief The dimensionality of this tuple.
     * @return the dimensionality of this tuple
     */
    constexpr static size_t dimensionality() {
        return _Dimensionality;
    }

    /** @invariant The dimensionality be a positive integral constant. */
    static_assert(IsDimensionality<_Dimensionality>::value, "_Dimensionality must fulfil the dimensionality concept");


	/** @brief @a MyType is the type of this template/template specialization. */
	using MyType = Tuple<ElementType, _Dimensionality>;


private:
	/**
	 * @brief
	 *  The elements of this tuple.
	 */
	std::array<ElementType, _Dimensionality> _elements;

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Generator construction.
protected:

    /**
     * @brief Construct this tuple with the values generated by a sequence generator.
     * @tparam _GeneratorType the generator type
     * @tparam ... Index indices 0, 1, ..., dimensionality() - 1
     */
    template <typename _GeneratorType, size_t ... Index>
    Tuple(const _GeneratorType& generator, std::index_sequence<Index ...>)
        : Tuple(generator(Index) ...) {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Direct construction.
protected:

	/**
	 * @brief Construct this tuple with the specified element values.
	 * @param first, ... rest the element values
     * @pre The number of specified element values must be equal to the dimensionality of the tuple type.
     * @pre Each specified element value must be convertible into the element type of the tuple type.
	 */
	template<
        typename ... ArgumentTypes,
        typename = 
            std::enable_if_t<
                (1 + sizeof...(ArgumentTypes)) == MyType::dimensionality() &&
                Core::AllConvertible<ElementType, ArgumentTypes ...>::value
            >
    >
	Tuple(ElementType&& first, ArgumentTypes&& ... rest)
		: _elements{ static_cast<ElementType>(first), static_cast<ElementType>(rest) ... } {
		static_assert(dimensionality() == 1 + sizeof ... (rest), "wrong number of arguments");
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Default construction.
protected:
	/**
	 * @brief
	 *	Default-construct this tuple.
	 */
	Tuple() : _elements() {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Copy construction.
protected:
	/**
	 * @brief
	 *  Copy-construct this tuple with the values of another tuple.
	 * @param other
	 *  the other tuple
	 */
	Tuple(const MyType& other) : _elements(other._elements) {}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Assignment.
protected:
	/**
	 * @brief
	 *  Assign this tuple with the values of another tuple.
	 * @param other
	 *  the other tuple
	 */
	void assign(const MyType& other) {
        for (auto i = 0; i < dimensionality(); ++i) {
            _elements[i] = other._elements[i];
        }
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Element access.
public:
	/**
	 * @{
	 * @brief Get the tuple element at the specified index.
	 * @param index the index
	 * @return the tuple element at the specified index
	 * @pre The index is within bounds.
	 */
	ElementType& at(size_t const& index) {
	#ifdef _DEBUG
		ID_ASSERT(index < dimensionality());
	#endif
		return _elements[index];
	}

	const ElementType& at(size_t const& index) const {
	#ifdef _DEBUG
		ID_ASSERT(index < dimensionality());
	#endif
		return _elements[index];
	}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
// Minimal/Maximal elements.

private:
    /** @internal */
    template <size_t ... Index>
    ElementType minhelper(std::index_sequence<Index ...>) const {
        return std::min({(this->_elements[Index]) ...});
    }

    /** @internal */
    template <size_t ... Index>
    ElementType maxhelper(std::index_sequence<Index ...>) const {
        return std::max({(this->_elements[Index]) ...});
    }


public:
    /**
     * @brief Get the minimum element value of this tuple.
     * @return the minimum element value of this tuple
     */
    ElementType min() const {
        return minhelper(std::index_sequence<MyType::dimensionality()>{});
    }

    /**
     * @brief Get the maximal element value of this tuple.
     * @return the maximal element value of this tuple
     */
    ElementType max() const {
        return maxhelper(std::index_sequence<MyType::dimensionality()>{});
    }

};

} // namespace Math
} // namespace Ego

namespace Ego {
namespace Math {
/**
 * Provide map functions for tuple, tuple x tuple, and tuple x tuple-element.
 * Provide fold functions for tuple and tuple x tuple.
 */
struct TupleUtilities {
public:
    /**
     * Given a tuple operand \f$x\f$ (of type \f$X\f$) compute a
     * tuple-like result \f$z\f$ (of type \f$Z\f$ ) such that
     * \f$z = Z(f(x[n]), ..., f(x[m]))\f$ where where \f$n \leq m\f$ and f is
     * binary functor \f$f : E(X) \rightarrow E(Z)\f$.
     */
    template <typename ResultType, typename ElementType, size_t Dimensionality, typename FunctorType, size_t... Index>
    static ResultType mapT(FunctorType functor, const Tuple<ElementType, Dimensionality>& x, std::index_sequence<Index ...>) {
        return ResultType((functor(x.at(Index)))...);
    }
    /**
     * Given one tuple-like operand \f$x\f$
     * and one tuple-element-like operand \f$y\f$
     * compute a tuple-like result \f$z\f$ such that
     * \f$z = Z(f(x[n],y), ..., f(x[m],y))\f$ where \f$n \leq m\f$ and f is an unary functor
     * \f$f : E(X) \times Y \rightarrow E(Z)\f$.
     */
    template <typename ResultType, typename ElementType0, typename ElementType1, size_t Dimensionality, typename FunctorType, size_t... Index>
    static ResultType mapTe(FunctorType functor, const Tuple<ElementType0,Dimensionality>& x, const ElementType1& y, std::index_sequence<Index ...>) {
        return ResultType((functor(x.at(Index),y))...);
    }
    // Given two tuple-like operands \f$x\f$ (of type \f$X\f$) and \f$y\f$ (of type \f$Y\f$),
    // compute a tuple-like result \f$z\f$ (of type \f$Z\f$) such that
    // \f$z = Z(f(x[n],y[n]),...,f(x[m],y[m]))\f$ where \f$n \leq m \f$ and \f$f\$ is
    // a binary functor \f$f : E(X) \times E(Y) \rightarrow E(Z)\f$.
    template <typename ResultType, typename ElementType0, typename ElementType1, size_t Dimensionality, typename FunctorType, size_t... Index>
    static ResultType mapTT(FunctorType functor, const Tuple<ElementType0, Dimensionality>& x, const Tuple<ElementType1, Dimensionality>& y, std::index_sequence<Index ...>) {
        return ResultType((functor(x.at(Index), y.at(Index)))...);
    }

public:
    template <typename FunctorType, typename ElementType, size_t Dimensionality>
    static decltype(auto) foldT(FunctorType functor, const typename FunctorType::ResultType& initialValue, const Tuple<ElementType, Dimensionality>& x) {
        auto t = initialValue;
        for (size_t i = 0; i < Dimensionality; ++i) {
            t = functor(t, x.at(i));
        }
        return t;
    }

    template <typename FunctorType, typename ElementType0, typename ElementType1, size_t Dimensionality>
    static decltype(auto) foldTT(FunctorType functor, const typename FunctorType::ResultType& initialValue, const Tuple<ElementType0, Dimensionality>& x, const Tuple<ElementType1, Dimensionality>& y) {
        auto t = initialValue;
        for (size_t i = 0; i < Dimensionality; ++i) {
            t = functor(t, x.at(i), y.at(i));
        }
        return t;
    }
};
} // namespace Math
} // namespace Ego
