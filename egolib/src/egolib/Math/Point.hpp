//********************************************************************************************
//*
//*    This file is part of Egoboo.
//*
//*    Egoboo is free software: you can redistribute it and/or modify it
//*    under the terms of the GNU General Public License as published by
//*    the Free Software Foundation, either version 3 of the License, or
//*    (at your option) any later version.
//*
//*    Egoboo is distributed in the hope that it will be useful, but
//*    WITHOUT ANY WARRANTY; without even the implied warranty of
//*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//*    General Public License for more details.
//*
//*    You should have received a copy of the GNU General Public License
//*    along with Egoboo.  If not, see <http://www.gnu.org/licenses/>.
//*
//********************************************************************************************

/// @file   egolib/Math/Point.hpp
/// @brief  Points.
/// @author Michael Heilmann

#pragma once

#include "egolib/Math/_Tuple.hpp"
#include "egolib/Math/_Generator.hpp"

namespace Ego {
namespace Math {

/// @brief A point in the \f$n\f$-dimensional Euclidean space.
/// @tparam _EuclideanSpace the Euclidean space over which the points are defined.
template <typename _VectorSpaceType>
struct Point : public Tuple<typename _VectorSpaceType::ScalarType, _VectorSpaceType::dimensionality()> {
public:
    /// @brief The vector space of this vector.
    typedef _VectorSpaceType VectorSpaceType;
    /// @brief The dimensionality.
    static constexpr size_t dimensionality() {
        return VectorSpaceType::dimensionality();
    }
    /// @brief The scalar field type (of the vector space).
    typedef typename VectorSpaceType::ScalarFieldType ScalarFieldType;
    /// @brief The vector type (of the vector space).
    typedef typename VectorSpaceType::VectorType VectorType;
    /// @brief The scalar type (of the scalar field).
    typedef typename VectorSpaceType::ScalarType ScalarType;

public:
    /// @brief The type of this template/template specialization.
    typedef Point<VectorSpaceType> MyType;
    /// @brief The tuple type.
    typedef Tuple<ScalarType, MyType::dimensionality()> TupleType;

public:
    /**
     * @brief Construct this point with the specified element values.
     * @param first, ... rest the element values
     * @pre The number of specified element values must be equal to the dimensionality of the point type.
     * @pre Each specified element value must be convertible into the element type of the point type.
     */
    template<
        typename ... ArgumentTypes,
        typename =
            std::enable_if_t<
                ((sizeof...(ArgumentTypes)) + 1) == MyType::dimensionality() &&
                Core::AllTrue<std::is_convertible<ArgumentTypes, ScalarType>::value ...>::value
            >
    >
    Point(ScalarType first, ArgumentTypes&& ... rest)
        : TupleType(std::forward<ScalarType>(first), rest ...) {
        static_assert(dimensionality() == 1 + sizeof ... (rest), "wrong number of arguments");
    }

    /**
     * @brief
     *  Copy-construct this poiint with the values of another point.
     * @param other
     *  the other point
     */
    Point(const MyType& other)
        : TupleType(other) {
        /* Intentionally empty. */
    }

protected:
    /**
     * @brief
     *  Construct this point with the values generated by a sequence generator.
     * @tparam _GeneratorType
     *  the generator type
     * @tparam ... Index
     *  indices 0, 1, ..., dimensionality() - 1
     */
    template <typename _GeneratorType, size_t ... Index>
    Point(const _GeneratorType& generator, std::index_sequence<Index ...>)
        : Point(generator(Index) ...) {}

public:
    /**
     * @brief
     *  Default-construct this point.
     */
    Point()
        : Point(ConstantGenerator<ScalarType>(ScalarFieldType::additiveNeutral()),
                std::make_index_sequence<VectorSpaceType::dimensionality()>{}) {
        /* Intentionally empty. */
    }

public:
    inline ScalarType& x() {
        static_assert(VectorSpaceType::dimensionality() >= 1, "cannot call for member x() with dimensionality less than 1");
        return this->at(0);
    }

    inline ScalarType& y() {
        static_assert(VectorSpaceType::dimensionality() >= 2, "cannot call for member y() with dimensionality less than 2");
        return this->at(1);
    }

    inline ScalarType& z() {
        static_assert(VectorSpaceType::dimensionality() >= 3, "cannot call for member z() with dimensionality less than 3");
        return this->at(2);
    }

    inline const ScalarType& x() const {
        static_assert(VectorSpaceType::dimensionality() >= 1, "cannot call for member x() with dimensionality less than 1");
        return this->at(0);
    }

    inline const ScalarType& y() const {
        static_assert(VectorSpaceType::dimensionality() >= 2, "cannot call for member y() with dimensionality less than 2");
        return this->at(1);
    }

    inline const ScalarType& z() const {
        static_assert(VectorSpaceType::dimensionality() >= 3, "cannot call for member z() with dimensionality less than 3");
        return this->at(2);
    }

public:
    /**
     * @brief
     *  Assign this point with the values of another point.
     * @param other
     *  the other point
     */
    void assign(const MyType& other) {
        TupleType::assign(other);
    }

    /**
     * @brief
     *  Set all elements in this point to zero.
     * @todo
     *  Remove this.
     */
    void setZero() {
        (*this) = MyType();
    }

public:
    /**
     * @brief
     *  Add a vector to this point,
     *  assign the result to this point.
     * @param other
     *  the vector
     * @post
     *  The sum <tt>(*this) + other</tt> was assigned to <tt>*this</tt>.
     */
    void add(const VectorType& other) {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            this->at(i) = ScalarFieldType::sum(this->at(i), other.at(i));
        }
    }

    /**
     * @brief
     *  Subtract a vector from this point,
     *  assign the result to this point.
     * @param other
     *  the vector
     * @post
     *  The difference <tt>(*this) - other</tt> was assigned to <tt>*this</tt>.
     */
    void sub(const VectorType& other) {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            this->at(i) = ScalarFieldType::difference(this->at(i), other.at(i));
        }
    }

public:
    /**
    * @brief
    *  Get if this point equals another point.
    * @param other
    *  the other point
    * @return
    *  @a true if this point equals the other point
    */
    bool equals(const MyType& other) const {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            if (ScalarFieldType::notEqualTo(this->at(i), other.at(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * @brief
     *  Get if this point equals another point.
     * @param other
     *  the other point
     * @param ulp
     *  see ScalarFieldType::notEqualUlp
     * @return
     *  @a true if this point equals the other point
     */
    bool equalsUlp(const MyType& other, const size_t& ulp) const {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            if (ScalarFieldType::notEqualULP(this->at(i), other.at(i), ulp)) {
                return false;
            }
        }
        return true;
    }

    /**
     * @brief
     *  Get if this point equals another point.
     * @param other
     *  the other point
     * @param tolerance
     *  see ScalarFieldType::notEqualTolerance
     * @return
     *  @a true if this point equals the other point
     */
    bool equalsTolerance(const MyType& other, const ScalarType& tolerance) const {
        for (size_t i = 0; i < MyType::dimensionality(); ++i) {
            if (ScalarFieldType::notEqualTolerance(this->at(i), other.at(i), tolerance)) {
                return false;
            }
        }
        return true;
    }

public:
    bool operator==(const MyType& other) const {
        return equals(other);
    }

    bool operator!=(const MyType& other) const {
        return !equals(other);
    }

public:
    // As always, return non-const reference in order to allow chaining for the sake of orthogonality.
    MyType& operator=(const MyType& other) {
        assign(other);
        return *this;
    }

public:
    MyType& operator+=(const VectorType& other) {
        add(other);
        return *this;
    }

    MyType& operator-=(const VectorType& other) {
        sub(other);
        return *this;
    }

public:
    MyType operator+(const VectorType& other) const {
        MyType t(*this);
        t += other;
        return t;
    }

    MyType operator-(const VectorType& other) const {
        MyType t(*this);
        t -= other;
        return t;
    }

private:
    /** @internal */
    ScalarType sub(const MyType& other, size_t index) const {
        return ScalarFieldType::difference(this->at(index), other.at(index));
    }
    /** @internal */
    template <size_t... Index>
    VectorType sub(const MyType& other, std::index_sequence<Index ...>) const {
        return VectorType((sub(other, Index))...);
    }
    VectorType sub(const MyType& other) const {
        return sub(other, std::make_index_sequence<VectorSpaceType::dimensionality()>{});
    }

public:
    VectorType operator-(const MyType& other) const {
        return sub(other);
    }

public:
    ScalarType& operator[](size_t const& index) {
        return this->at(index);
    }

    const ScalarType& operator[](size_t const& index) const {
        return this->at(index);
    }

public:
    /**
     * @brief
     *  Get the zero point.
     * @return
     *  the zero point
     */
    static const MyType& zero() {
        static ConstantGenerator<ScalarType> g(ScalarFieldType::additiveNeutral());
        static const auto v = MyType(g, std::make_index_sequence<VectorSpaceType::dimensionality()>{});
        return v;
    }


}; // struct Point

} // namespace Math
} // namespace Ego
